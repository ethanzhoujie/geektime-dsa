

#### 数据结构分类

##### 线性表数据结构

线性表数据结构只有前和后两个方向

![](./assets/linearlist.jpg)

##### 非线性表数据结构

在非线性表数据结构中不只有前后关系

![](./assets/nonlinearlist.jpg)



#### 如何实现数据的随机访问

连续的内存空间和相同类型的数据是随机访问的关键

```
a[i]_address = base_address + i * data_type_size
```



#### 数组和链表的区别

链表适合插入和删除，时间复杂度为 O(1)；数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)



#### 分析一下数组的“插入”和“删除”

##### 插入操作

对于 size 为 n 的数组，如何在第 k 的位置插入一个数据，时间复杂度是多少。

- 需要保持原有数据的相对位置

需要把 k ~ n 的数据都顺序的往后移一位

1. 如果是在末尾插入数据，其他数据则不需要移动，时间复杂度为 O(1)
2. 如果是在数组的开头插入数据，则所有的元素需要往后移一位，时间复杂度 O(n)
3. 所以平均时间复杂度为 (1+2+…+n)/n = O(n)

- 不需要保持原有数据的相对位置

直接将第 k 个元素移到数组元素的最后，新元素放到第 k 个位置，时间复杂度为 O(1)

Assume the array below has enough space.

![](./assets/array_insert.jpg)

##### 删除操作

在执行删除操作的时候，需要把删除元素的后续元素依次向前移动，否则数组就会出现空洞，导致内存不连续。

1. 如果删除最后一个元素，O(1)
2. 如果删除的是第一个元素，O(n)
3. 所以平均时间复杂度为 O(n)

**改进方法**：

如果要依次删除数组中的 a，b，c

![](./assets/array_delete.jpg)

为了避免剩余数据会被移动三次，可以记录下要删除的数据， 当数组没有更多空间存储数据时，再执行一次真正的删除操作，这样就大大减少了删除操作导致的数据移动。这就是 JVM 标记清除垃圾回收算法的核心思想。



#### 容器能否完全代替数组

ArrayList：

1. 可以将数组操作的细节封装起来
2. 支持动态扩容，自动扩容为 1.5 倍大小，不过最好在创建 ArrayList 的时候事先指定数据大小

Array：

1. Java ArrayList 无法存储基本类型，比如 int、long，需要封装为 Integer、Long 类，而 Autoboxing、Unboxing 则有一定的性能消耗。
2. 如果数据大小事先已知，并且对数据的操作非常简单，用不到 ArrayList 的大部分方法，也可以直接使用数组。
3. 表示多维数组时，用数组往往更加直观。比如 Object[]\[] = array; 而容器则需要 ArrayList\<ArrayList> array。